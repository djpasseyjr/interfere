from abc import ABC, abstractmethod
from typing import Callable, Optional

import numpy as np

from .utils import copy_doc

# Default range for random number generation.
DEFAULT_RANGE = np.random.default_rng()


class DynamicModel(ABC):
    """Abstract base class for dynamic models.
    
    Any dynamic model that implements an appropriate `simulate` method
    can be used for dynamic counterfactual analysis. 
    """


    def __init__(
        self,
        dim: int, 
        measurement_noise_std: Optional[np.ndarray] = None,
    ):
        """Initializes a DynamicModel instance.

        Args:
            dim: The number of dimensions in the multivariate time series
                generated by the dynamic model.
            measurement_noise_std (ndarray): None, or a vector with shape (n,)
                where each entry corresponds to the standard deviation of the
                measurement noise for that particular dimension of the dynamic
                model. For example, if the dynamic model had two variables x1
                and x2 and `measurement_noise_std = [1, 10]`, then
                independent gaussian noise with standard deviation 1 and 10
                will be added to x1 and x2 respectively at each point in time.
        """
        self.dim = dim
        self.measurement_noise_std = measurement_noise_std


    def simulate(
        self,
        t: np.ndarray,
        prior_states: np.ndarray,
        prior_t: Optional[np.ndarray] = None,
        intervention: Optional[Callable[[np.ndarray, float], np.ndarray]]= None,
        rng: np.random.mtrand.RandomState = DEFAULT_RANGE,
        **kwargs
    ) -> np.ndarray:
        """Runs a simulation of the dynamic model.

        Args:
            t (ndarray): A (n,) array of the time points where the   
                dynamic model will be simulated. The first entry of `t` must
                equal the last entry of `prior_t`. If `prior_t` is None, then
                the values of `prior_t` will be assumed to be evenly spaced time
                values ending with the first entry of `t`. If `t` does not
                contain evenly spaced time values, then the inference of
                `prior_t` will throw an error.
            prior_states (ndarray): A (m,) or (p, m) array of the initial
                condition or the prior states of the system.
            prior_t (ndarray): A time array with shape (p,) corresponding to the
                rows of `prior_states`. The last entry of `prior_t` must equal
                the first entry of `t`. If `prior_t` is None, then
                the values of `prior_t` will be assumed to be evenly spaced time
                values ending with the first entry of `t`. If `t` does not
                contain evenly spaced time values, then the inference of
                `prior_t` will throw an error.
            intervention (callable): A function that accepts (1) a vector of the
                current state of the dynamic model and (2) the current time. It should return a modified state. The function will be used in the
                following way. If the dynamic model without the intervention can be described 
                as
                
                x(t+dt) = F(x(t))
                
                where dt is the timestep size, x(t) is the trajectory, and F is
                the function that uses the current state to compute the state at
                the next timestep. Then the intervention function will be used
                to simulate the system

                    z(t+dt) = F(g(z(t), t), t)
                    x_do(t) = g(z(t), t)

                where x_do is the trajectory of the intervened system and g is 
                the intervention function.
            rng (RandomState): A numpy random state for reproducibility. (Uses 
                numpy's mtrand random number generator by default.)

        Returns:
            X (ndarray): An (n, m) array containing a realization of the   
                trajectory of the m dimensional system corresponding to the n
                times in `t`. The first row of X contains the last row of 
                `prior_states`.
        """
        # Must provide at least one unseen simulation time.
        if len(t) < 2:
            raise ValueError(f"len(t) = {len(t)} but at least two time points must be provided to simulate.")
        
        # Reshape prior_states to ensure they are 2D
        prior_states = np.reshape(prior_states, (-1, prior_states.shape[-1]))
        p, _ = prior_states.shape     

        if prior_t is not None:
            p_prior_t, = prior_t.shape

            if p_prior_t != p:
                raise ValueError(f"The length of `prior_t` ({p_prior_t}) must "
                    f"be equal to the number of rows ({p}) in prior_states. "
                )
            
            if prior_t[-1] != t[0]:
                raise ValueError(f"The last prior time, `prior_t[-1] "
                    f"= {prior_t[-1]}` must equal the first simulation time "
                    f"`t[0] = {t[0]}`."
                )
            
        else:
            # No prior times provided. We infer prior times.
            dt = t[1] - t[0]
            if not np.allclose(np.diff(t) - dt, 0.0):
                raise ValueError(
                    "Attempted to infer `prior_t` but `t` does not "
                    "have evenly spaced time points. Use evenly spaced `t` or "
                    "pass `prior_t` explicitly."
                )

            start_time = t[0]
            # Evenly spaced prior times ending at the start of t.
            prior_t = np.arange(start_time - p * dt, start_time + dt, dt)

        return self._simulate(
            t, prior_states, prior_t, intervention, rng, **kwargs)
                

            
    

    def add_measurement_noise(
        self,
        X: np.ndarray,
        rng: np.random.mtrand.RandomState = DEFAULT_RANGE,
    ):
        """Adds independent gaussian noise to the array X.

        Only adds noise if self.measurement_noise_std is not None.

        Adds gaussian noise to each column. Equivalent to
            X[i, j] += normal() * stdevs[j]
        For all i and j.

        Args:
            X (ndarray): An (m, n) matrix that is interpreted to be a  
                realization of an n dimensional stochastic multivariate timeseries.
            measurement_noise_std (ndarray): An (n,) array that contains the
                standard deviations of the gaussian noise that will be added to
                each of the columns.
            rng: A numpy random state for reproducibility. (Uses numpy's mtrand 
                random number generator by default.)

        Returns:
            Xhat (ndarray): An (m, n) matrix that is equivalent to X + normally
                normally distributed noise.
        """
        if self.measurement_noise_std is None:
            return X
        
        return X + rng.standard_normal(X.shape) * self.measurement_noise_std
    

    @abstractmethod
    @copy_doc(simulate)
    def _simulate(
        self,
        t: np.ndarray,
        prior_states: np.ndarray,
        prior_t: Optional[np.ndarray] = None,
        intervention: Optional[Callable[[np.ndarray, float], np.ndarray]]= None,
        rng: np.random.mtrand.RandomState = DEFAULT_RANGE,
        **kwargs
    ) -> np.ndarray:
        raise NotImplementedError


class Intervention(ABC):
    """Abstract intervention class"""
    
    @abstractmethod
    def __call__():
        raise NotImplementedError