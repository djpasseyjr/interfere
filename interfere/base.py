from abc import ABC, abstractmethod
from typing import Callable, Optional, Union

import numpy as np

from .utils import copy_doc

# Default range for random number generation.
DEFAULT_RANGE = np.random.default_rng()


class DynamicModel(ABC):
    """Abstract base class for dynamic models.
    
    Any dynamic model that implements an appropriate `simulate` method
    can be used for dynamic counterfactual analysis. 
    """


    def __init__(
        self,
        dim: int, 
        measurement_noise_std: Optional[np.ndarray] = None,
        sigma: Optional[Union[float, np.ndarray]] = None
    ):
        """Initializes a DynamicModel instance.

        Args:
            dim: The number of dimensions in the multivariate time series
                generated by the dynamic model.
            measurement_noise_std (ndarray): None, or a vector with shape (n,)
                where each entry corresponds to the standard deviation of the
                measurement noise for that particular dimension of the dynamic
                model. For example, if the dynamic model had two variables x1
                and x2 and `measurement_noise_std = [1, 10]`, then
                independent gaussian noise with standard deviation 1 and 10
                will be added to x1 and x2 respectively at each point in time.
            sigma (float or ndarray): The stochastic noise parameter. Can be a
                float, a 1D matrix or a 2D matrix. Dimension must match
                dimension of model.
        """
        self.dim = dim
        self.measurement_noise_std = measurement_noise_std
        self.sigma = self.build_stochastic_noise_matrix(sigma, dim)


    def simulate(
        self,
        t: np.ndarray,
        prior_states: np.ndarray,
        prior_t: Optional[np.ndarray] = None,
        intervention: Optional[Callable[[np.ndarray, float], np.ndarray]]= None,
        rng: np.random.mtrand.RandomState = DEFAULT_RANGE,
        **kwargs
    ) -> np.ndarray:
        """Runs a simulation of the dynamic model.

        Args:
            t (ndarray): A (n,) array of the time points where the   
                dynamic model will be simulated. The first entry of `t` must
                equal the last entry of `prior_t`. If `prior_t` is None, then
                the values of `prior_t` will be assumed to be evenly spaced time
                values ending with the first entry of `t`. If `t` does not
                contain evenly spaced time values, then the inference of
                `prior_t` will throw an error.
            prior_states (ndarray): A (m,) or (p, m) array of the initial
                condition or the prior states of the system.
            prior_t (ndarray): A time array with shape (p,) corresponding to the
                rows of `prior_states`. The last entry of `prior_t` must equal
                the first entry of `t`. If `prior_t` is None, then
                the values of `prior_t` will be assumed to be evenly spaced time
                values ending with the first entry of `t`. If `t` does not
                contain evenly spaced time values, then the inference of
                `prior_t` will throw an error.
            intervention (callable): A function that accepts (1) a vector of the
                current state of the dynamic model and (2) the current time. It should return a modified state. The function will be used in the
                following way. If the dynamic model without the intervention can be described 
                as
                
                x(t+dt) = F(x(t))
                
                where dt is the timestep size, x(t) is the trajectory, and F is
                the function that uses the current state to compute the state at
                the next timestep. Then the intervention function will be used
                to simulate the system

                    z(t+dt) = F(g(z(t), t), t)
                    x_do(t) = g(z(t), t)

                where x_do is the trajectory of the intervened system and g is 
                the intervention function.
            rng (RandomState): A numpy random state for reproducibility. (Uses 
                numpy's mtrand random number generator by default.)

        Returns:
            X (ndarray): An (n, m) array containing a realization of the   
                trajectory of the m dimensional system corresponding to the n
                times in `t`. The first row of X contains the last row of 
                `prior_states`.
        """
        # Must provide at least one unseen simulation time.
        if len(t) < 2:
            raise ValueError(f"len(t) = {len(t)} but at least two time points must be provided to simulate.")
        
        # Reshape prior_states to ensure they are 2D
        prior_states = np.reshape(prior_states, (-1, prior_states.shape[-1]))
        prior_obs, _ = prior_states.shape     

        if prior_t is not None:
            p_prior_t, = prior_t.shape

            if p_prior_t != prior_obs:
                raise ValueError(f"The length of `prior_t` ({p_prior_t}) must "
                    f"be equal to the number of rows ({prior_obs}) in prior_states. "
                )
            
            if prior_t[-1] != t[0]:
                raise ValueError(f"The last prior time, `prior_t[-1] "
                    f"= {prior_t[-1]}` must equal the first simulation time "
                    f"`t[0] = {t[0]}`."
                )
            
        else:
            # No prior times provided. We infer prior times.
            dt = t[1] - t[0]
            if not np.allclose(np.diff(t) - dt, 0.0):
                raise ValueError(
                    "Attempted to infer `prior_t` but `t` does not "
                    "have evenly spaced time points. Use evenly spaced `t` or "
                    "pass `prior_t` explicitly."
                )

            start_time = t[0]
            # Evenly spaced prior times ending at the start of t.
            prior_t = np.arange(-prior_obs + 1, 1) * dt + start_time

        return self._simulate(
            t, prior_states, prior_t, intervention, rng, **kwargs)
                

            
    

    def add_measurement_noise(
        self,
        X: np.ndarray,
        rng: np.random.mtrand.RandomState = DEFAULT_RANGE,
    ):
        """Adds independent gaussian noise to the array X.

        Only adds noise if self.measurement_noise_std is not None.

        Adds gaussian noise to each column. Equivalent to
            X[i, j] += normal() * stdevs[j]
        For all i and j.

        Args:
            X (ndarray): An (m, n) matrix that is interpreted to be a  
                realization of an n dimensional stochastic multivariate timeseries.
            measurement_noise_std (ndarray): An (n,) array that contains the
                standard deviations of the gaussian noise that will be added to
                each of the columns.
            rng: A numpy random state for reproducibility. (Uses numpy's mtrand 
                random number generator by default.)

        Returns:
            Xhat (ndarray): An (m, n) matrix that is equivalent to X + normally
                normally distributed noise.
        """
        if self.measurement_noise_std is None:
            return X
        
        return X + rng.standard_normal(X.shape) * self.measurement_noise_std
    

    def build_stochastic_noise_matrix(
        self,
        sigma: Union[float, np.ndarray],
        dim: int
    ) -> np.ndarray:
        """Helper function that creates a fixed noise rescaling matrix.

        If sigma is a float, returns a diagonal matrix with sigma on diagonal.
        If sigma is a 1D array, returns a diagonal matrix with diagonal equal to
        sigma. If sigma is a 2D array, checks dimension and returns sigma.

        Args:
            sigma (float or ndarray): The stochastic noise parameter. Can be a
                float, a 1D matrix or a 2D matrix. Dimension must match
                dimension of model.
            dim (int): The desired dimension of the noise matrix.

        Returns:
            A numpy array with shape (dim, dim).
        """
        # If sigma is a float, make a diagnonal matrix.
        if isinstance(sigma, (float, int)):
            return np.eye(dim) * sigma
        
        # If sigma is a 1D array, check dimension and put it on the diagonal.
        elif isinstance(sigma, np.ndarray) and len(sigma.shape) == 1:

            if sigma.shape[0] != dim:
                raise ValueError(
                    f"The stochastic noise parameter for {type(self).__name__} "
                    f"was the incorrect size: `sigma.shape = {sigma.shape}`. "
                    f"Pass a float or `sigma` with shape ({dim},) or "
                    "({dim}, {dim}).")
            
            return np.diag(sigma)
        
        elif isinstance(sigma, np.ndarray) and len(sigma.shape) == 2:
            if sigma.shape != (dim, dim):
                raise ValueError(
                    f"The stochastic noise parameter for {type(self).__name__} "
                    f"was the incorrect size: `sigma.shape = {sigma.shape}`. "
                    f"Pass a float or `sigma` with shape ({dim},) or "
                    "({dim}, {dim}).")
            return sigma
        
        if sigma is None:
            return np.zeros((dim, dim))
        else:
            raise ValueError(
                f"The stochastic noise parameter for {type(self).__name__}"
                " must be a float or a 1 or 2 dimensional numpy array."
            )
    

    @abstractmethod
    @copy_doc(simulate)
    def _simulate(
        self,
        t: np.ndarray,
        prior_states: np.ndarray,
        prior_t: Optional[np.ndarray] = None,
        intervention: Optional[Callable[[np.ndarray, float], np.ndarray]]= None,
        rng: np.random.mtrand.RandomState = DEFAULT_RANGE,
        **kwargs
    ) -> np.ndarray:
        raise NotImplementedError


class Intervention(ABC):
    """Abstract intervention class"""
    
    @abstractmethod
    def __call__():
        raise NotImplementedError