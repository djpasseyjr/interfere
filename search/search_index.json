{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\ud83c\udf00 Interfere: Intervention Response Prediction in Complex Dynamic Models Interfere is a comprehensive Python toolkit for simulating, intervening on, and optimizing forecasting methods to predict the behavior complex dynamical systems. It enables: Rich collections of continuous and discrete-time dynamic models (ODEs, SDEs, differnce equations, and more). Exogenous interventions to generate control and treatment scenarios at scale. Seamless forecasting integrations (SINDy, VAR, reservoir computing, ARIMA, LSTM, NHITS). Automated sliding-window cross-validation and hyperparameter tuning with Optuna. Unified error metrics and evaluation workflows for intervention-response prediction. Interfere Benchmark Dataset ( Download ) The image above depicts the uninterrupted trajectories of sixty dynamic models in blue and their response to a particular intervention in red. This data is available for download as the Interfere Benchmark 1.1.1 . It can be used to benchmark a forecasting method's ability to predict the response of a dynamic system to interventions. Installation Install the core package from PyPI: pip install interfere For Nixtla-based forecasting methods ( ARIMA , LSTM , NHITS ), install the extras: pip install interfere[nixtla] Quick Start The Interfere package is designed around three main tasks: counterfactual simulation, predictive method optimization, and prediction. Here's a complete example using the SINDy (Sparse Identification of Nonlinear Dynamics) method: 1. Counterfactual Simulation First, let's create and simulate a dynamic model: import numpy as np import interfere import optuna # Set up simulation parameters initial_cond = np.random.rand(3) t_train = np.arange(0, 10, 0.05) dynamics = interfere.dynamics.Belozyorov3DQuad(sigma=0.5) # Generate trajectory sim_states = dynamics.simulate(t_train, initial_cond) 2. Applying an Intervention Next, we'll apply an intervention to one component of the system: # Time points for the intervention simulation test_t = np.arange(t_train[-1], 15, 0.05) # Intervention initialization intervention = interfere.SignalIntervention(iv_idxs=1, signals=np.sin) # Simulate intervention interv_states = dynamics.simulate( test_t, prior_states=sim_states, intervention=intervention, ) 3. Model Optimization and Prediction Using the generated data, we can run hyperparameter optimization with a forecasting method. All forecasting methods come with reasonable hyperparameter ranges built in. # Select the SINDy method for hyperparameter optimization. method_type = interfere.SINDy # Create an objective function that aims to minimize cross validation error # over different hyper parameter configurations for SINDy cv_obj = interfere.CrossValObjective( method_type=method_type, data=sim_states, times=t_train, train_window_percent=0.3, num_folds=5, exog_idxs=intervention.iv_idxs, ) # Run the study using optuna. study = optuna.create_study() study.optimize(cv_obj, n_trials=25) # Collect the best hyperparameters into a dictionary. best_param_dict = study.best_params 4. Intervention Response Prediction Using the best parameters found, we can fit the forecasting method to pre-intervention data and then make a prediction about how the system will respond to the intervention. # Initialize SINDy with the best perfoming parameters. method = interfere.SINDy(**study.best_params) # Use an intervention helper function to split the pre-intervention data # into endogenous and exogenous columns. Y_endog, Y_exog = intervention.split_exog(sim_states) # Fit SINDy to the pre-intervention data. method.fit(t_train, Y_endog, Y_exog) # Use the inherited interfere.ForecastingMethod.simulate() method # To simulate intervention response using SINDy pred_traj = method.simulate( test_t, prior_states=sim_states, intervention=intervention ) The SINDy method identifies the underlying dynamics of the system using sparse regression techniques, making it particularly effective for discovering interpretable mathematical models of complex systems. Documentation Simulation : Simulation engines and available dynamic models. Intervention : Exogenous intervention interfaces. Optimization : Automated cross-validation and hyperparameter tuning. Prediction : Counterfactual forecasting workflows.","title":"Home"},{"location":"#interfere-intervention-response-prediction-in-complex-dynamic-models","text":"Interfere is a comprehensive Python toolkit for simulating, intervening on, and optimizing forecasting methods to predict the behavior complex dynamical systems. It enables: Rich collections of continuous and discrete-time dynamic models (ODEs, SDEs, differnce equations, and more). Exogenous interventions to generate control and treatment scenarios at scale. Seamless forecasting integrations (SINDy, VAR, reservoir computing, ARIMA, LSTM, NHITS). Automated sliding-window cross-validation and hyperparameter tuning with Optuna. Unified error metrics and evaluation workflows for intervention-response prediction.","title":"\ud83c\udf00 Interfere: Intervention Response Prediction in Complex Dynamic Models"},{"location":"#interfere-benchmark-dataset-download","text":"The image above depicts the uninterrupted trajectories of sixty dynamic models in blue and their response to a particular intervention in red. This data is available for download as the Interfere Benchmark 1.1.1 . It can be used to benchmark a forecasting method's ability to predict the response of a dynamic system to interventions.","title":"Interfere Benchmark Dataset (Download)"},{"location":"#installation","text":"Install the core package from PyPI: pip install interfere For Nixtla-based forecasting methods ( ARIMA , LSTM , NHITS ), install the extras: pip install interfere[nixtla]","title":"Installation"},{"location":"#quick-start","text":"The Interfere package is designed around three main tasks: counterfactual simulation, predictive method optimization, and prediction. Here's a complete example using the SINDy (Sparse Identification of Nonlinear Dynamics) method:","title":"Quick Start"},{"location":"#1-counterfactual-simulation","text":"First, let's create and simulate a dynamic model: import numpy as np import interfere import optuna # Set up simulation parameters initial_cond = np.random.rand(3) t_train = np.arange(0, 10, 0.05) dynamics = interfere.dynamics.Belozyorov3DQuad(sigma=0.5) # Generate trajectory sim_states = dynamics.simulate(t_train, initial_cond)","title":"1. Counterfactual Simulation"},{"location":"#2-applying-an-intervention","text":"Next, we'll apply an intervention to one component of the system: # Time points for the intervention simulation test_t = np.arange(t_train[-1], 15, 0.05) # Intervention initialization intervention = interfere.SignalIntervention(iv_idxs=1, signals=np.sin) # Simulate intervention interv_states = dynamics.simulate( test_t, prior_states=sim_states, intervention=intervention, )","title":"2. Applying an Intervention"},{"location":"#3-model-optimization-and-prediction","text":"Using the generated data, we can run hyperparameter optimization with a forecasting method. All forecasting methods come with reasonable hyperparameter ranges built in. # Select the SINDy method for hyperparameter optimization. method_type = interfere.SINDy # Create an objective function that aims to minimize cross validation error # over different hyper parameter configurations for SINDy cv_obj = interfere.CrossValObjective( method_type=method_type, data=sim_states, times=t_train, train_window_percent=0.3, num_folds=5, exog_idxs=intervention.iv_idxs, ) # Run the study using optuna. study = optuna.create_study() study.optimize(cv_obj, n_trials=25) # Collect the best hyperparameters into a dictionary. best_param_dict = study.best_params","title":"3. Model Optimization and Prediction"},{"location":"#4-intervention-response-prediction","text":"Using the best parameters found, we can fit the forecasting method to pre-intervention data and then make a prediction about how the system will respond to the intervention. # Initialize SINDy with the best perfoming parameters. method = interfere.SINDy(**study.best_params) # Use an intervention helper function to split the pre-intervention data # into endogenous and exogenous columns. Y_endog, Y_exog = intervention.split_exog(sim_states) # Fit SINDy to the pre-intervention data. method.fit(t_train, Y_endog, Y_exog) # Use the inherited interfere.ForecastingMethod.simulate() method # To simulate intervention response using SINDy pred_traj = method.simulate( test_t, prior_states=sim_states, intervention=intervention ) The SINDy method identifies the underlying dynamics of the system using sparse regression techniques, making it particularly effective for discovering interpretable mathematical models of complex systems.","title":"4. Intervention Response Prediction"},{"location":"#documentation","text":"Simulation : Simulation engines and available dynamic models. Intervention : Exogenous intervention interfaces. Optimization : Automated cross-validation and hyperparameter tuning. Prediction : Counterfactual forecasting workflows.","title":"Documentation"},{"location":"intervention/","text":"Intervention Apply external manipulations to a dynamic model and observe system responses. Intervention Types Intervention Class Description IdentityIntervention No-op intervention PerfectIntervention Replace variables with constant values SignalIntervention Apply time-varying signals to selected variables Example import numpy as np from interfere.dynamics import Lorenz from interfere.interventions import PerfectIntervention, SignalIntervention # Simulation setup t = np.linspace(0, 10, 500) x0 = np.array([1.0, 1.0, 1.0]) model = Lorenz(sigma=0.0) # No intervention states_orig = model.simulate(t, x0) # Perfect intervention: set first variable to constant 5.0 after t=0 i = PerfectIntervention(0, 5.0) states_perfect = model.simulate(t, x0, intervention=i) # Signal intervention: sinusoidal forcing on second variable i2 = SignalIntervention(1, np.sin) states_signal = model.simulate(t, x0, intervention=i2) # Inspect first five time points of perfect intervention print(states_perfect[:5])","title":"Intervention"},{"location":"intervention/#intervention","text":"Apply external manipulations to a dynamic model and observe system responses.","title":"Intervention"},{"location":"intervention/#intervention-types","text":"Intervention Class Description IdentityIntervention No-op intervention PerfectIntervention Replace variables with constant values SignalIntervention Apply time-varying signals to selected variables","title":"Intervention Types"},{"location":"intervention/#example","text":"import numpy as np from interfere.dynamics import Lorenz from interfere.interventions import PerfectIntervention, SignalIntervention # Simulation setup t = np.linspace(0, 10, 500) x0 = np.array([1.0, 1.0, 1.0]) model = Lorenz(sigma=0.0) # No intervention states_orig = model.simulate(t, x0) # Perfect intervention: set first variable to constant 5.0 after t=0 i = PerfectIntervention(0, 5.0) states_perfect = model.simulate(t, x0, intervention=i) # Signal intervention: sinusoidal forcing on second variable i2 = SignalIntervention(1, np.sin) states_signal = model.simulate(t, x0, intervention=i2) # Inspect first five time points of perfect intervention print(states_perfect[:5])","title":"Example"},{"location":"optimization/","text":"Optimization Interfere's optimization module provides a robust cross-validation workflow for hyperparameter tuning of dynamical forecasting methods using Optuna. CrossValObjective Overview The CrossValObjective class implements an Optuna-compatible objective function for tuning any ForecastMethod . It performs sliding-window cross-validation on time series data, systematically training and scoring forecasting or intervention-response models over multiple folds. Key Parameters method_type (Type[ForecastMethod]) : Forecasting method class (e.g., SINDy , VAR , ResComp ). data (np.ndarray) : Time series array of shape (T, n_vars). Rows are time points, columns are variables. times (np.ndarray) : 1D array of time stamps corresponding to each row in data . train_window_percent (float) : Fraction of data used for training in each fold (0 < p < 1). num_folds (int) : Total number of folds (including the initial training window). exog_idxs (Optional[list[int]]) : Indices of columns in data treated as exogenous variables during fitting and validation. val_scheme (str) : Validation strategy: \"forecast\" (score the chunk immediately after training), \"last\" (score a fixed hold-out chunk at end), or \"all\" (score all hold-out chunks). num_val_prior_states (int) : Number of prior observations used as context for each validation prediction. metric (Callable[[np.ndarray, np.ndarray], float]) : Callable metric function accepting actual and predicted arrays and returning a scalar error (e.g., interfere.metrics.rmse ). metric_direction (str) : \"minimize\" or \"maximize\" , passed to Optuna's study. hyperparam_func (Callable) : Trial-to-parameter mapping function. Defaults to the model's _get_optuna_params . store_preds (bool) : If True , stores per-fold predictions in CrossValObjective.trial_results for inspection. raise_errors (bool) : If True , propagates exceptions during CV; otherwise, assigns a large penalty value for that trial. Metrics Interfere provides simple callable metrics in the interfere.metrics module. Metrics should accept two arrays ( actual , predicted ) of the same shape and return a float. Exogenous variables will be automatically dropped during metric evaluation. Function Description interfere.metrics.rmse Root mean squared error interfere.metrics.mae Mean absolute error interfere.metrics.mse Mean squared error interfere.metrics.mape Mean absolute percentage error interfere.metrics.nrmse Normalized root mean squared error interfere.metrics.rmsse Root mean squared scaled error Example: import interfere # compute error between observed and forecasted values error = interfere.metrics.rmse(actual, predicted) Cross-Validation Workflow Partition Data : Split data into a sliding training window (size = train_window_percent \u00d7 T) and subsequent validation chunks. Slide Window : For each of the num_folds , advance the training window by one validation chunk and retrain the forecasting method from scratch. Score Predictions : Depending on val_scheme , compute the error metric on hold-out observations immediately after training ( \"forecast\" ), at the end ( \"last\" ), or on all chunks ( \"all\" ). Aggregate Result : Return the aggregated metric across folds to Optuna to guide hyperparameter search. Supported Forecasting Methods Method Description AverageMethod Forecasts the historical mean VAR Vector autoregression via StatsModels SINDy Sparse regression-based identification of dynamics ResComp Reservoir computing with Tikhonov regularization ARIMA Classical time series ARIMA model via Nixtla StatsForecast LSTM Long Short-Term Memory RNN forecaster via Nixtla NeuralForecast NHITS NHITS deep learning forecaster via Nixtla NeuralForecast Example Usage import numpy as np import interfere import optuna # 1. Simulate training data t = np.linspace(0, 10, 500) x0 = np.random.rand(3) dynamics = interfere.dynamics.Lorenz(sigma=0.3) data = dynamics.simulate(t, x0) # 2. Initialize CrossValObjective cv = interfere.CrossValObjective( method_type=interfere.SINDy, data=data, times=t, train_window_percent=0.5, num_folds=4, exog_idxs=[], val_scheme=\"forecast\", num_val_prior_states=5, metric=interfere.metrics.RootMeanSquaredError(), metric_direction=\"minimize\", ) # 3. Optimize with Optuna study = optuna.create_study(direction=cv.metric_direction) study.optimize(cv, n_trials=20) print(\"Best hyperparameters:\", study.best_params)","title":"Optimization"},{"location":"optimization/#optimization","text":"Interfere's optimization module provides a robust cross-validation workflow for hyperparameter tuning of dynamical forecasting methods using Optuna.","title":"Optimization"},{"location":"optimization/#crossvalobjective-overview","text":"The CrossValObjective class implements an Optuna-compatible objective function for tuning any ForecastMethod . It performs sliding-window cross-validation on time series data, systematically training and scoring forecasting or intervention-response models over multiple folds.","title":"CrossValObjective Overview"},{"location":"optimization/#key-parameters","text":"method_type (Type[ForecastMethod]) : Forecasting method class (e.g., SINDy , VAR , ResComp ). data (np.ndarray) : Time series array of shape (T, n_vars). Rows are time points, columns are variables. times (np.ndarray) : 1D array of time stamps corresponding to each row in data . train_window_percent (float) : Fraction of data used for training in each fold (0 < p < 1). num_folds (int) : Total number of folds (including the initial training window). exog_idxs (Optional[list[int]]) : Indices of columns in data treated as exogenous variables during fitting and validation. val_scheme (str) : Validation strategy: \"forecast\" (score the chunk immediately after training), \"last\" (score a fixed hold-out chunk at end), or \"all\" (score all hold-out chunks). num_val_prior_states (int) : Number of prior observations used as context for each validation prediction. metric (Callable[[np.ndarray, np.ndarray], float]) : Callable metric function accepting actual and predicted arrays and returning a scalar error (e.g., interfere.metrics.rmse ). metric_direction (str) : \"minimize\" or \"maximize\" , passed to Optuna's study. hyperparam_func (Callable) : Trial-to-parameter mapping function. Defaults to the model's _get_optuna_params . store_preds (bool) : If True , stores per-fold predictions in CrossValObjective.trial_results for inspection. raise_errors (bool) : If True , propagates exceptions during CV; otherwise, assigns a large penalty value for that trial.","title":"Key Parameters"},{"location":"optimization/#metrics","text":"Interfere provides simple callable metrics in the interfere.metrics module. Metrics should accept two arrays ( actual , predicted ) of the same shape and return a float. Exogenous variables will be automatically dropped during metric evaluation. Function Description interfere.metrics.rmse Root mean squared error interfere.metrics.mae Mean absolute error interfere.metrics.mse Mean squared error interfere.metrics.mape Mean absolute percentage error interfere.metrics.nrmse Normalized root mean squared error interfere.metrics.rmsse Root mean squared scaled error Example: import interfere # compute error between observed and forecasted values error = interfere.metrics.rmse(actual, predicted)","title":"Metrics"},{"location":"optimization/#cross-validation-workflow","text":"Partition Data : Split data into a sliding training window (size = train_window_percent \u00d7 T) and subsequent validation chunks. Slide Window : For each of the num_folds , advance the training window by one validation chunk and retrain the forecasting method from scratch. Score Predictions : Depending on val_scheme , compute the error metric on hold-out observations immediately after training ( \"forecast\" ), at the end ( \"last\" ), or on all chunks ( \"all\" ). Aggregate Result : Return the aggregated metric across folds to Optuna to guide hyperparameter search.","title":"Cross-Validation Workflow"},{"location":"optimization/#supported-forecasting-methods","text":"Method Description AverageMethod Forecasts the historical mean VAR Vector autoregression via StatsModels SINDy Sparse regression-based identification of dynamics ResComp Reservoir computing with Tikhonov regularization ARIMA Classical time series ARIMA model via Nixtla StatsForecast LSTM Long Short-Term Memory RNN forecaster via Nixtla NeuralForecast NHITS NHITS deep learning forecaster via Nixtla NeuralForecast","title":"Supported Forecasting Methods"},{"location":"optimization/#example-usage","text":"import numpy as np import interfere import optuna # 1. Simulate training data t = np.linspace(0, 10, 500) x0 = np.random.rand(3) dynamics = interfere.dynamics.Lorenz(sigma=0.3) data = dynamics.simulate(t, x0) # 2. Initialize CrossValObjective cv = interfere.CrossValObjective( method_type=interfere.SINDy, data=data, times=t, train_window_percent=0.5, num_folds=4, exog_idxs=[], val_scheme=\"forecast\", num_val_prior_states=5, metric=interfere.metrics.RootMeanSquaredError(), metric_direction=\"minimize\", ) # 3. Optimize with Optuna study = optuna.create_study(direction=cv.metric_direction) study.optimize(cv, n_trials=20) print(\"Best hyperparameters:\", study.best_params)","title":"Example Usage"},{"location":"prediction/","text":"Prediction Prediction in Interfere empowers you to translate fitted forecasting methods into precise counterfactual system trajectories. By leveraging the same simulate interface, you can compare baseline dynamics to intervention-driven responses with minimal code changes. API Reference: fit() & predict() fit() fit( self, t: np.ndarray, endog_states: np.ndarray, exog_states: Optional[np.ndarray] = None, ) -> ForecastMethod t (np.ndarray) : 1D array of time points with shape (n,) , strictly increasing. endog_states (np.ndarray) : 2D array (n, d) of endogenous variable observations. exog_states (Optional[np.ndarray]) : 2D array (n, k) of exogenous signals; defaults to no exogenous inputs. Returns : The fitted forecasting method instance ( self ). predict() predict( self, t: np.ndarray, prior_endog_states: np.ndarray, prior_exog_states: Optional[np.ndarray] = None, prior_t: Optional[np.ndarray] = None, prediction_exog: Optional[np.ndarray] = None, prediction_max: float = 1e9, rng: np.random.RandomState = DEFAULT_RANGE ) -> np.ndarray t (np.ndarray) : 1D array (m,) of future time points to predict. prior_endog_states (np.ndarray) : 2D array (p, d) of historic endogenous observations used as initial conditions or lagged values. prior_exog_states (Optional[np.ndarray]) : 2D array (p, k) of historic exogenous signals. prior_t (Optional[np.ndarray]) : 1D array (p,) of times corresponding to prior_*_states . If None , inferred from t spacing. prediction_exog (Optional[np.ndarray]) : 2D array (m, k) of future exogenous inputs. prediction_max (float) : Threshold to cap predictions and prevent overflow. rng (np.random.RandomState) : Random state for reproducible stochastic forecasts. Returns : A 2D array (m, d) of predicted endogenous states, including the first row as the initial condition. Prediction Methods Use any forecasting method that inherits from ForecastMethod . Method Description AverageMethod Baseline forecast using average historical data VAR Vector autoregression forecast using statsmodels SINDy Sparse model identification for nonlinear dynamics ResComp Reservoir computing forecast with Tikhonov regularization ARIMA Classical time series ARIMA model via Nixtla StatsForecast LSTM Long Short-Term Memory RNN forecaster via Nixtla NeuralForecast NHITS NHITS deep learning forecaster via Nixtla NeuralForecast Example import numpy as np import interfere # Pre-intervention simulation t = np.arange(0, 10, 0.1) x0 = np.random.rand(2) dynamics = interfere.dynamics.Lorenz(sigma=0.2) states = dynamics.simulate(t, x0) # Define intervention interv = interfere.PerfectIntervention(0, 2.0) # Generate pre-intervention data t0 = t n_endog, n_exog = states.shape[1]-len(interv.iv_idxs), len(interv.iv_idxs) endog, exog = interv.split_exog(states) # Fit SINDy to pre-intervention data method = interfere.SINDy() method.fit(t0, endog, exog) # Forecast with intervention t_pred = np.arange(t[-1], t[-1]+5, 0.1) pred_states = method.simulate(t_pred, states, intervention=interv) # Inspect predicted states shape print(pred_states.shape) # (50, endog+exog dims)","title":"Prediction"},{"location":"prediction/#prediction","text":"Prediction in Interfere empowers you to translate fitted forecasting methods into precise counterfactual system trajectories. By leveraging the same simulate interface, you can compare baseline dynamics to intervention-driven responses with minimal code changes.","title":"Prediction"},{"location":"prediction/#api-reference-fit-predict","text":"","title":"API Reference: fit() &amp; predict()"},{"location":"prediction/#fit","text":"fit( self, t: np.ndarray, endog_states: np.ndarray, exog_states: Optional[np.ndarray] = None, ) -> ForecastMethod t (np.ndarray) : 1D array of time points with shape (n,) , strictly increasing. endog_states (np.ndarray) : 2D array (n, d) of endogenous variable observations. exog_states (Optional[np.ndarray]) : 2D array (n, k) of exogenous signals; defaults to no exogenous inputs. Returns : The fitted forecasting method instance ( self ).","title":"fit()"},{"location":"prediction/#predict","text":"predict( self, t: np.ndarray, prior_endog_states: np.ndarray, prior_exog_states: Optional[np.ndarray] = None, prior_t: Optional[np.ndarray] = None, prediction_exog: Optional[np.ndarray] = None, prediction_max: float = 1e9, rng: np.random.RandomState = DEFAULT_RANGE ) -> np.ndarray t (np.ndarray) : 1D array (m,) of future time points to predict. prior_endog_states (np.ndarray) : 2D array (p, d) of historic endogenous observations used as initial conditions or lagged values. prior_exog_states (Optional[np.ndarray]) : 2D array (p, k) of historic exogenous signals. prior_t (Optional[np.ndarray]) : 1D array (p,) of times corresponding to prior_*_states . If None , inferred from t spacing. prediction_exog (Optional[np.ndarray]) : 2D array (m, k) of future exogenous inputs. prediction_max (float) : Threshold to cap predictions and prevent overflow. rng (np.random.RandomState) : Random state for reproducible stochastic forecasts. Returns : A 2D array (m, d) of predicted endogenous states, including the first row as the initial condition.","title":"predict()"},{"location":"prediction/#prediction-methods","text":"Use any forecasting method that inherits from ForecastMethod . Method Description AverageMethod Baseline forecast using average historical data VAR Vector autoregression forecast using statsmodels SINDy Sparse model identification for nonlinear dynamics ResComp Reservoir computing forecast with Tikhonov regularization ARIMA Classical time series ARIMA model via Nixtla StatsForecast LSTM Long Short-Term Memory RNN forecaster via Nixtla NeuralForecast NHITS NHITS deep learning forecaster via Nixtla NeuralForecast","title":"Prediction Methods"},{"location":"prediction/#example","text":"import numpy as np import interfere # Pre-intervention simulation t = np.arange(0, 10, 0.1) x0 = np.random.rand(2) dynamics = interfere.dynamics.Lorenz(sigma=0.2) states = dynamics.simulate(t, x0) # Define intervention interv = interfere.PerfectIntervention(0, 2.0) # Generate pre-intervention data t0 = t n_endog, n_exog = states.shape[1]-len(interv.iv_idxs), len(interv.iv_idxs) endog, exog = interv.split_exog(states) # Fit SINDy to pre-intervention data method = interfere.SINDy() method.fit(t0, endog, exog) # Forecast with intervention t_pred = np.arange(t[-1], t[-1]+5, 0.1) pred_states = method.simulate(t_pred, states, intervention=interv) # Inspect predicted states shape print(pred_states.shape) # (50, endog+exog dims)","title":"Example"},{"location":"simulation/","text":"Simulation Simulation in Interfere brings mathematical models to life, offering a unified framework for producing deterministic, stochastic, and hybrid trajectories under controlled interventions. Whether you're exploring classic ODE behavior or complex SDE landscapes, Interfere handles the heavy lifting\u2014time management, noise, and interventions\u2014so you can focus on analysis. At the heart of Interfere's simulation engine is the abstract DynamicModel class (in interfere/base.py ), which provides: Argument Validation : Ensures t , prior_states , and prior_t shapes are consistent. Time Inference : Infers or checks historic time points ( prior_t ) if not supplied. Noise Injection : Builds and injects system (stochastic) and measurement noise. Intervention Hooks : Manages optional application of exogenous intervention functions. Subclasses implement the protected _simulate() method to define the specific propagation rules. With these foundational services\u2014validation, time inference, noise injection, and intervention hooks\u2014Interfere enables seamless simulation of everything from classic ODEs to complex SDEs and discrete-time maps. In interfere/dynamics/base.py , three specialized simulation bases implement _simulate() : OrdinaryDifferentialEquation : Integrates ODEs by defining a dXdt(x, t) derivative function and calling scipy.integrate.odeint , applies interventions at each step, and adds measurement noise. StochasticDifferentialEquation : Advances SDEs using an Euler\u2013Maruyama scheme, computing deterministic drift(x, t) and stochastic noise(x, t) dW , supports custom Wiener increments, applies interventions, and adds measurement noise. DiscreteTimeDynamics : Steps discrete-time maps by repeatedly calling a step(x, t) function, applying optional interventions after each step. Below is a table of every dynamic model provided in interfere/dynamics (as imported in its __init__.py ), showing each model name, its direct base class, and a concise description. simulate() Method The simulate method is the primary interface for generating time-series trajectories of a DynamicModel . It handles initial conditions, optional interventions, stochastic process noise, and measurement noise, delivering a complete counterfactual or baseline trajectory. simulate( self, t: np.ndarray, prior_states: np.ndarray, prior_t: Optional[np.ndarray] = None, intervention: Optional[Callable[[np.ndarray, float], np.ndarray]] = None, rng: np.random.RandomState = DEFAULT_RANGE, **kwargs ) -> np.ndarray Parameters: t ( np.ndarray of shape (n,) ): Strictly increasing time points for simulation ('), requiring at least two entries for integration. prior_states ( np.ndarray ): Initial condition(s). Can be a 1D array of length dim or a 2D array (p, dim) representing p historic observations. prior_t ( Optional[np.ndarray] of shape (p,) ): Time stamps for each row of prior_states . If omitted and t is uniform, historic times are inferred as evenly spaced before t[0] . intervention ( Optional[Callable[[x: np.ndarray, t: float], np.ndarray]] ): A function to impose exogenous control at each step. Defaults to no intervention. rng ( numpy.random.RandomState ): RNG used for generating process ( sigma ) and measurement noise. kwargs : Additional subclass-specific options (e.g., dW for custom Wiener increments in SDEs). Returns: np.ndarray (n, dim) : Simulated state trajectory over t , incorporating any interventions and noise effects. Model Base Class Description ArithmeticBrownianMotion StochasticDifferentialEquation Brownian motion with linear drift and constant diffusion GeometricBrownianMotion StochasticDifferentialEquation Geometric Brownian motion with multiplicative noise OrdinaryDifferentialEquation DynamicModel Abstract base for continuous-time ODE integrators StochasticDifferentialEquation DynamicModel Abstract base for SDE simulators LinearSDE StochasticDifferentialEquation Linear stochastic differential equation DampedOscillator StochasticDifferentialEquation Second-order damped oscillator modeled as SDE imag_roots_2d_linear_sde LinearSDE (factory) 2D linear SDE with purely imaginary eigenvalues imag_roots_4d_linear_sde LinearSDE (factory) 4D linear SDE with purely imaginary eigenvalues attracting_fixed_point_4d_linear_sde LinearSDE (factory) 4D SDE with an attracting fixed point CoupledMapLattice DiscreteTimeDynamics Deterministic coupled map lattice StochasticCoupledMapLattice CoupledMapLattice Coupled map lattice with stochastic fluctuations coupled_logistic_map StochasticCoupledMapLattice (factory) Factory: stochastic logistic map lattice coupled_map_1dlattice_chaotic_brownian StochasticCoupledMapLattice (factory) Factory: chaotic Brownian CML coupled_map_1dlattice_chaotic_traveling_wave StochasticCoupledMapLattice (factory) Factory: chaotic traveling-wave CML coupled_map_1dlattice_defect_turbulence StochasticCoupledMapLattice (factory) Factory: defect turbulence CML coupled_map_1dlattice_frozen_chaos StochasticCoupledMapLattice (factory) Factory: frozen chaos CML coupled_map_1dlattice_pattern_selection StochasticCoupledMapLattice (factory) Factory: pattern selection CML coupled_map_1dlattice_spatiotemp_chaos StochasticCoupledMapLattice (factory) Factory: spatiotemporal chaos CML coupled_map_1dlattice_spatiotemp_intermit1 StochasticCoupledMapLattice (factory) Factory: intermittency type 1 CML coupled_map_1dlattice_spatiotemp_intermit2 StochasticCoupledMapLattice (factory) Factory: intermittency type 2 CML coupled_map_1dlattice_traveling_wave StochasticCoupledMapLattice (factory) Factory: traveling-wave CML Kuramoto StochasticDifferentialEquation Coupled oscillator network KuramotoSakaguchi StochasticDifferentialEquation Kuramoto variant with phase frustration LotkaVoltera OrdinaryDifferentialEquation Predator\u2013prey ODE model LotkaVolteraSDE StochasticDifferentialEquation Stochastic predator\u2013prey model MichaelisMenten StochasticDifferentialEquation Enzyme kinetics reaction network MutualisticPopulation OrdinaryDifferentialEquation Interacting mutualistic species model SIS StochasticDifferentialEquation Susceptible\u2013Infected\u2013Susceptible epidemiological model OrnsteinUhlenbeck StochasticDifferentialEquation Mean-reverting Ornstein\u2013Uhlenbeck process VARMADynamics DynamicModel Vector autoregressive moving-average dynamics WilsonCowan OrdinaryDifferentialEquation Wilson\u2013Cowan neural population model Belozyorov3DQuad StochasticDifferentialEquation 3D quadratic chaotic system Liping3DQuadFinance StochasticDifferentialEquation 3D quadratic system for financial modeling Lorenz StochasticDifferentialEquation Lorenz chaotic attractor Rossler StochasticDifferentialEquation R\u00f6ssler attractor Thomas StochasticDifferentialEquation Thomas chaotic attractor MooreSpiegel StochasticDifferentialEquation Moore\u2013Spiegel chaotic oscillator PlantedTankNitrogenCycle OrdinaryDifferentialEquation Aquatic nitrogen cycle model GenerativeForecaster DynamicModel Generates trajectories using fitted forecasters generative_lorenz_VAR_forecaster GenerativeForecaster (factory) Factory: VAR-based Lorenz forecaster generative_cml_SINDy_forecaster GenerativeForecaster (factory) Factory: SINDy-based CML forecaster StandardNormalNoise DiscreteTimeDynamics IID Gaussian noise generator StandardCauchyNoise DiscreteTimeDynamics IID Cauchy noise generator StandardExponentialNoise DiscreteTimeDynamics IID exponential noise generator StandardGammaNoise DiscreteTimeDynamics IID gamma noise generator StandardTNoise DiscreteTimeDynamics IID Student's t noise generator","title":"Simulation"},{"location":"simulation/#simulation","text":"Simulation in Interfere brings mathematical models to life, offering a unified framework for producing deterministic, stochastic, and hybrid trajectories under controlled interventions. Whether you're exploring classic ODE behavior or complex SDE landscapes, Interfere handles the heavy lifting\u2014time management, noise, and interventions\u2014so you can focus on analysis. At the heart of Interfere's simulation engine is the abstract DynamicModel class (in interfere/base.py ), which provides: Argument Validation : Ensures t , prior_states , and prior_t shapes are consistent. Time Inference : Infers or checks historic time points ( prior_t ) if not supplied. Noise Injection : Builds and injects system (stochastic) and measurement noise. Intervention Hooks : Manages optional application of exogenous intervention functions. Subclasses implement the protected _simulate() method to define the specific propagation rules. With these foundational services\u2014validation, time inference, noise injection, and intervention hooks\u2014Interfere enables seamless simulation of everything from classic ODEs to complex SDEs and discrete-time maps. In interfere/dynamics/base.py , three specialized simulation bases implement _simulate() : OrdinaryDifferentialEquation : Integrates ODEs by defining a dXdt(x, t) derivative function and calling scipy.integrate.odeint , applies interventions at each step, and adds measurement noise. StochasticDifferentialEquation : Advances SDEs using an Euler\u2013Maruyama scheme, computing deterministic drift(x, t) and stochastic noise(x, t) dW , supports custom Wiener increments, applies interventions, and adds measurement noise. DiscreteTimeDynamics : Steps discrete-time maps by repeatedly calling a step(x, t) function, applying optional interventions after each step. Below is a table of every dynamic model provided in interfere/dynamics (as imported in its __init__.py ), showing each model name, its direct base class, and a concise description.","title":"Simulation"},{"location":"simulation/#simulate-method","text":"The simulate method is the primary interface for generating time-series trajectories of a DynamicModel . It handles initial conditions, optional interventions, stochastic process noise, and measurement noise, delivering a complete counterfactual or baseline trajectory. simulate( self, t: np.ndarray, prior_states: np.ndarray, prior_t: Optional[np.ndarray] = None, intervention: Optional[Callable[[np.ndarray, float], np.ndarray]] = None, rng: np.random.RandomState = DEFAULT_RANGE, **kwargs ) -> np.ndarray Parameters: t ( np.ndarray of shape (n,) ): Strictly increasing time points for simulation ('), requiring at least two entries for integration. prior_states ( np.ndarray ): Initial condition(s). Can be a 1D array of length dim or a 2D array (p, dim) representing p historic observations. prior_t ( Optional[np.ndarray] of shape (p,) ): Time stamps for each row of prior_states . If omitted and t is uniform, historic times are inferred as evenly spaced before t[0] . intervention ( Optional[Callable[[x: np.ndarray, t: float], np.ndarray]] ): A function to impose exogenous control at each step. Defaults to no intervention. rng ( numpy.random.RandomState ): RNG used for generating process ( sigma ) and measurement noise. kwargs : Additional subclass-specific options (e.g., dW for custom Wiener increments in SDEs). Returns: np.ndarray (n, dim) : Simulated state trajectory over t , incorporating any interventions and noise effects. Model Base Class Description ArithmeticBrownianMotion StochasticDifferentialEquation Brownian motion with linear drift and constant diffusion GeometricBrownianMotion StochasticDifferentialEquation Geometric Brownian motion with multiplicative noise OrdinaryDifferentialEquation DynamicModel Abstract base for continuous-time ODE integrators StochasticDifferentialEquation DynamicModel Abstract base for SDE simulators LinearSDE StochasticDifferentialEquation Linear stochastic differential equation DampedOscillator StochasticDifferentialEquation Second-order damped oscillator modeled as SDE imag_roots_2d_linear_sde LinearSDE (factory) 2D linear SDE with purely imaginary eigenvalues imag_roots_4d_linear_sde LinearSDE (factory) 4D linear SDE with purely imaginary eigenvalues attracting_fixed_point_4d_linear_sde LinearSDE (factory) 4D SDE with an attracting fixed point CoupledMapLattice DiscreteTimeDynamics Deterministic coupled map lattice StochasticCoupledMapLattice CoupledMapLattice Coupled map lattice with stochastic fluctuations coupled_logistic_map StochasticCoupledMapLattice (factory) Factory: stochastic logistic map lattice coupled_map_1dlattice_chaotic_brownian StochasticCoupledMapLattice (factory) Factory: chaotic Brownian CML coupled_map_1dlattice_chaotic_traveling_wave StochasticCoupledMapLattice (factory) Factory: chaotic traveling-wave CML coupled_map_1dlattice_defect_turbulence StochasticCoupledMapLattice (factory) Factory: defect turbulence CML coupled_map_1dlattice_frozen_chaos StochasticCoupledMapLattice (factory) Factory: frozen chaos CML coupled_map_1dlattice_pattern_selection StochasticCoupledMapLattice (factory) Factory: pattern selection CML coupled_map_1dlattice_spatiotemp_chaos StochasticCoupledMapLattice (factory) Factory: spatiotemporal chaos CML coupled_map_1dlattice_spatiotemp_intermit1 StochasticCoupledMapLattice (factory) Factory: intermittency type 1 CML coupled_map_1dlattice_spatiotemp_intermit2 StochasticCoupledMapLattice (factory) Factory: intermittency type 2 CML coupled_map_1dlattice_traveling_wave StochasticCoupledMapLattice (factory) Factory: traveling-wave CML Kuramoto StochasticDifferentialEquation Coupled oscillator network KuramotoSakaguchi StochasticDifferentialEquation Kuramoto variant with phase frustration LotkaVoltera OrdinaryDifferentialEquation Predator\u2013prey ODE model LotkaVolteraSDE StochasticDifferentialEquation Stochastic predator\u2013prey model MichaelisMenten StochasticDifferentialEquation Enzyme kinetics reaction network MutualisticPopulation OrdinaryDifferentialEquation Interacting mutualistic species model SIS StochasticDifferentialEquation Susceptible\u2013Infected\u2013Susceptible epidemiological model OrnsteinUhlenbeck StochasticDifferentialEquation Mean-reverting Ornstein\u2013Uhlenbeck process VARMADynamics DynamicModel Vector autoregressive moving-average dynamics WilsonCowan OrdinaryDifferentialEquation Wilson\u2013Cowan neural population model Belozyorov3DQuad StochasticDifferentialEquation 3D quadratic chaotic system Liping3DQuadFinance StochasticDifferentialEquation 3D quadratic system for financial modeling Lorenz StochasticDifferentialEquation Lorenz chaotic attractor Rossler StochasticDifferentialEquation R\u00f6ssler attractor Thomas StochasticDifferentialEquation Thomas chaotic attractor MooreSpiegel StochasticDifferentialEquation Moore\u2013Spiegel chaotic oscillator PlantedTankNitrogenCycle OrdinaryDifferentialEquation Aquatic nitrogen cycle model GenerativeForecaster DynamicModel Generates trajectories using fitted forecasters generative_lorenz_VAR_forecaster GenerativeForecaster (factory) Factory: VAR-based Lorenz forecaster generative_cml_SINDy_forecaster GenerativeForecaster (factory) Factory: SINDy-based CML forecaster StandardNormalNoise DiscreteTimeDynamics IID Gaussian noise generator StandardCauchyNoise DiscreteTimeDynamics IID Cauchy noise generator StandardExponentialNoise DiscreteTimeDynamics IID exponential noise generator StandardGammaNoise DiscreteTimeDynamics IID gamma noise generator StandardTNoise DiscreteTimeDynamics IID Student's t noise generator","title":"simulate() Method"}]}